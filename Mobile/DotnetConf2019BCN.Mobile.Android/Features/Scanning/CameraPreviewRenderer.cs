using System.Collections.Generic;
using System.Threading.Tasks;
using Android.App;
using Android.Content;
using Android.Graphics;
using Android.Hardware.Camera2;
using Android.Hardware.Camera2.Params;
using Android.Media;
using Android.OS;
using Android.Provider;
using Android.Util;
using Android.Views;
using Java.Lang;
using Java.Util;
using Java.Util.Concurrent;
using Plugin.CurrentActivity;
using DotnetConf2019BCN.Mobile.Droid.Features.Scanning;
using DotnetConf2019BCN.Mobile.Droid.ThirdParties.Camera;
using DotnetConf2019BCN.Mobile.Droid.ThirdParties.Camera.Listeners;
using DotnetConf2019BCN.Mobile.Features.Scanning;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Android;
using Boolean = Java.Lang.Boolean;
using Orientation = Android.Content.Res.Orientation;
using Point = Android.Graphics.Point;
using Size = Android.Util.Size;

[assembly: ExportRenderer(typeof(CameraPreview), typeof(CameraPreviewRenderer))]
namespace DotnetConf2019BCN.Mobile.Droid.Features.Scanning
{
    public class CameraPreviewRenderer : ViewRenderer<CameraPreview, AutoFitTextureView>, ICamera
    {
        // Max preview width that is guaranteed by Camera2 API
        private static readonly int MAX_PREVIEW_WIDTH = 1920;

        // Max preview height that is guaranteed by Camera2 API
        private static readonly int MAX_PREVIEW_HEIGHT = 1080;

        // TextureView.ISurfaceTextureListener handles several lifecycle events on a TextureView
        private CameraSurfaceTextureListener mSurfaceTextureListener;

        // ID of the current {@link CameraDevice}.
        private string mCameraId;

        // An AutoFitTextureView for camera preview
        private AutoFitTextureView mTextureView;

        // A {@link CameraCaptureSession } for camera preview.
        public CameraCaptureSession mCaptureSession { get; set; }

        // A reference to the opened CameraDevice
        public CameraDevice mCameraDevice { get; set; }

        // The size of the camera preview
        private Size mPreviewSize;

        // CameraDevice.StateListener is called when a CameraDevice changes its state
        private CameraStateListener mStateCallback;

        // An additional thread for running tasks that shouldn't block the UI.
        private HandlerThread mBackgroundThread;

        // A {@link Handler} for running tasks in the background.
        public Handler mBackgroundHandler { get; set; }

        // An {@link ImageReader} that handles still image capture.
        private ImageReader mImageReader;

        // This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
        // still image is ready to be saved.
        private ImageAvailableListener mOnImageAvailableListener;

        // {@link CaptureRequest.Builder} for the camera preview
        public CaptureRequest.Builder mPreviewRequestBuilder { get; set; }

        // {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
        public CaptureRequest mPreviewRequest { get; set; }

        // The current state of camera state for taking pictures.
        public CameraState mState { get; set; } = CameraState.STATE_PREVIEW;

        // A {@link Semaphore} to prevent the app from exiting before closing the camera.
        public Semaphore mCameraOpenCloseLock { get; set; } = new Semaphore(1);

        // Whether the current camera device supports Flash or not.
        private bool mFlashSupported;

        // Orientation of the camera sensor
        private int mSensorOrientation;

        public Activity Activity { get; set; }

        private static readonly SparseIntArray Orientations = new SparseIntArray();

        public CameraPreviewRenderer(Context context)
            : base(context)
        {
            Orientations.Append((int)SurfaceOrientation.Rotation0, 90);
            Orientations.Append((int)SurfaceOrientation.Rotation90, 0);
            Orientations.Append((int)SurfaceOrientation.Rotation180, 270);
            Orientations.Append((int)SurfaceOrientation.Rotation270, 180);
        }

        protected override void OnElementChanged(ElementChangedEventArgs<CameraPreview> e)
        {
            if (Xamarin.Forms.DesignMode.IsDesignModeEnabled)
            {
                return;
            }

            if (e.OldElement != null) //// Clear old element event
            {
            }

            this.element = e.NewElement;
            if (element == null)
            {
                return;
            }

            element.TakePicture = () => { return TakePictureAsync(); };

            if (Control == null)
            {
                Activity = this.Context as Activity;
                SetNativeControl(new AutoFitTextureView(Context));
            }

            mTextureView = Control as AutoFitTextureView;
            mStateCallback = new CameraStateListener(this);
            mSurfaceTextureListener = new CameraSurfaceTextureListener(this);
            mOnImageAvailableListener = new ImageAvailableListener(this);

            if (element.EnableTensorflowAnalysis)
            {
                mOnImageAvailableListener.EnableTensorflowAnalysis();
            }

            StartTheCamera();

            base.OnElementChanged(e);
        }

        private void StartTheCamera()
        {
            StartBackgroundThread();

            // When the screen is turned off and turned back on, the SurfaceTexture is already
            // available, and "onSurfaceTextureAvailable" will not be called. In that case, we can open
            // a camera and start preview from here (otherwise, we wait until the surface is ready in
            // the SurfaceTextureListener).
            if (mTextureView.IsAvailable)
            {
                OpenCamera(mTextureView.Width, mTextureView.Height);
            }
            else
            {
                mTextureView.SurfaceTextureListener = mSurfaceTextureListener;
            }
        }

        public void OnCaptureComplete(string path)
        {
            SaveImageToGallery(path);
            captureTcs.TrySetResult(path);
        }

        private void SaveImageToGallery(string path)
        {
            var values = new ContentValues();
            values.Put(MediaStore.Images.ImageColumns.DateTaken, Java.Lang.JavaSystem.CurrentTimeMillis());
            values.Put(MediaStore.Images.ImageColumns.MimeType, "image/jpeg");
            values.Put(MediaStore.MediaColumns.Data, path);

            CrossCurrentActivity.Current.Activity.ContentResolver.Insert(
                MediaStore.Images.Media.ExternalContentUri, 
                values);
        }

        private static Size ChooseOptimalSize(
            Size[] choices,
            int textureViewWidth,
            int textureViewHeight,
            int maxWidth,
            int maxHeight,
            Size aspectRatio)
        {
            // Collect the supported resolutions that are at least as big as the preview Surface
            var bigEnough = new List<Size>();

            // Collect the supported resolutions that are smaller than the preview Surface
            var notBigEnough = new List<Size>();
            int w = aspectRatio.Width;
            int h = aspectRatio.Height;

            for (var i = 0; i < choices.Length; i++)
            {
                Size option = choices[i];
                if ((option.Width <= maxWidth) && (option.Height <= maxHeight) &&
                       option.Height == option.Width * h / w)
                {
                    if (option.Width >= textureViewWidth &&
                        option.Height >= textureViewHeight)
                    {
                        bigEnough.Add(option);
                    }
                    else
                    {
                        notBigEnough.Add(option);
                    }
                }
            }

            // Pick the smallest of those big enough. If there is no one big enough, pick the
            // largest of those not big enough.
            if (bigEnough.Count > 0)
            {
                return (Size)Collections.Min(bigEnough, new CompareSizesByArea());
            }
            else if (notBigEnough.Count > 0)
            {
                return (Size)Collections.Max(notBigEnough, new CompareSizesByArea());
            }
            else
            {
                System.Console.WriteLine("Couldn't find any suitable preview size");
                return choices[0];
            }
        }

        // Sets up member variables related to camera.
        private void SetUpCameraOutputs(int width, int height)
        {
            var activity = Activity;
            var manager = (CameraManager)activity.GetSystemService(Context.CameraService);
            try
            {
                for (var i = 0; i < manager.GetCameraIdList().Length; i++)
                {
                    var cameraId = manager.GetCameraIdList()[i];
                    CameraCharacteristics characteristics = manager.GetCameraCharacteristics(cameraId);

                    // We don't use a front facing camera in this sample.
                    var facing = (Integer)characteristics.Get(CameraCharacteristics.LensFacing);
                    if (facing != null && facing == Integer.ValueOf((int)LensFacing.Front))
                    {
                        continue;
                    }

                    var map = (StreamConfigurationMap)characteristics.Get(
                        CameraCharacteristics.ScalerStreamConfigurationMap);
                    if (map == null)
                    {
                        continue;
                    }

                    // For still image captures, we use the largest available size.
                    Size largest = (Size)Collections.Max(
                        Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg)),
                        new CompareSizesByArea());

                    ConfigureImageReader(largest);

                    bool swappedDimensions = GetDimmensions(activity, characteristics);

                    Point displaySize = new Point();
                    activity.WindowManager.DefaultDisplay.GetSize(displaySize);
                    var rotatedPreviewWidth = width;
                    var rotatedPreviewHeight = height;
                    var maxPreviewWidth = displaySize.X;
                    var maxPreviewHeight = displaySize.Y;

                    if (swappedDimensions)
                    {
                        rotatedPreviewWidth = height;
                        rotatedPreviewHeight = width;
                        maxPreviewWidth = displaySize.Y;
                        maxPreviewHeight = displaySize.X;
                    }

                    if (maxPreviewWidth > MAX_PREVIEW_WIDTH)
                    {
                        maxPreviewWidth = MAX_PREVIEW_WIDTH;
                    }

                    if (maxPreviewHeight > MAX_PREVIEW_HEIGHT)
                    {
                        maxPreviewHeight = MAX_PREVIEW_HEIGHT;
                    }

                    // Danger, W.R.! Attempting to use too large a preview size could  exceed the camera
                    // bus' bandwidth limitation, resulting in gorgeous previews but the storage of
                    // garbage capture data.
                    mPreviewSize = ChooseOptimalSize(
                        map.GetOutputSizes(Class.FromType(typeof(SurfaceTexture))),
                        rotatedPreviewWidth,
                        rotatedPreviewHeight,
                        maxPreviewWidth,
                        maxPreviewHeight,
                        largest);

                    // We fit the aspect ratio of TextureView to the size of preview we picked.
                    var orientation = Resources.Configuration.Orientation;
                    if (orientation == Orientation.Landscape)
                    {
                        mTextureView.SetAspectRatio(mPreviewSize.Width, mPreviewSize.Height);
                    }
                    else
                    {
                        mTextureView.SetAspectRatio(mPreviewSize.Height, mPreviewSize.Width);
                    }

                    // Check if the flash is supported.
                    var available = (Boolean)characteristics.Get(CameraCharacteristics.FlashInfoAvailable);
                    if (available == null)
                    {
                        mFlashSupported = false;
                    }
                    else
                    {
                        mFlashSupported = (bool)available;
                    }

                    mCameraId = cameraId;
                    return;
                }
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (NullPointerException)
            {
                // Currently an NPE is thrown when the Camera2API is used but not supported on the
                // device this code runs.
                // ErrorDialog.NewInstance(GetString(Resource.String.camera_error)).
                // Show(ChildFragmentManager, FRAGMENT_DIALOG);
            }
        }

        private void ConfigureImageReader(Size largest)
        {
            var imageWidth = largest.Width;
            var imageHeight = largest.Height;

            if (element.EnableTensorflowAnalysis)
            {
                imageWidth = imageHeight = TensorflowLiteService.ModelInputSize;
            }

            mImageReader = ImageReader.NewInstance(
                imageWidth,
                imageHeight,
                ImageFormatType.Jpeg,
                maxImages: 1);
            mImageReader.SetOnImageAvailableListener(
                mOnImageAvailableListener,
                mBackgroundHandler);
        }

        private bool GetDimmensions(Activity activity, CameraCharacteristics characteristics)
        {
            // Find out if we need to swap dimension to get the preview size relative to sensor
            // coordinate.
            var displayRotation = activity.WindowManager.DefaultDisplay.Rotation;

            // noinspection ConstantConditions
            mSensorOrientation = (int)characteristics.Get(CameraCharacteristics.SensorOrientation);
            bool swappedDimensions = false;
            switch (displayRotation)
            {
                case SurfaceOrientation.Rotation0:
                case SurfaceOrientation.Rotation180:
                    if (mSensorOrientation == 90 || mSensorOrientation == 270)
                    {
                        swappedDimensions = true;
                    }

                    break;
                case SurfaceOrientation.Rotation90:
                case SurfaceOrientation.Rotation270:
                    if (mSensorOrientation == 0 || mSensorOrientation == 180)
                    {
                        swappedDimensions = true;
                    }

                    break;
                default:
                    System.Console.WriteLine("Display rotation is invalid: " + displayRotation);
                    break;
            }

            return swappedDimensions;
        }

        // Opens the camera specified by {@link Camera2BasicFragment#mCameraId}.
        public void OpenCamera(int width, int height)
        {
            SetUpCameraOutputs(width, height);
            var activity = Activity;
            var manager = (CameraManager)activity.GetSystemService(Context.CameraService);
            try
            {
                if (!mCameraOpenCloseLock.TryAcquire(2500, TimeUnit.Milliseconds))
                {
                    throw new RuntimeException("Time out waiting to lock camera opening.");
                }

                if (!string.IsNullOrEmpty(mCameraId))
                {
                    manager.OpenCamera(mCameraId, mStateCallback, mBackgroundHandler);
                }
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
            }
        }

        // Closes the current {@link CameraDevice}.
        private void CloseCamera()
        {
            if (mCaptureSession == null)
            {
                return;
            }

            try
            {
                mCameraOpenCloseLock.Acquire();
                if (mCaptureSession != null)
                {
                    try
                    {
                        mCaptureSession.StopRepeating();
                        mCaptureSession.AbortCaptures();
                    }
                    catch (CameraAccessException e)
                    {
                        e.PrintStackTrace();
                    }
                    catch (IllegalStateException e)
                    {
                        e.PrintStackTrace();
                    }

                    mCaptureSession.Close();
                    mCaptureSession = null;
                }

                if (mCameraDevice != null)
                {
                    mCameraDevice.Close();
                    mCameraDevice = null;
                }

                if (mImageReader != null)
                {
                    mImageReader.Close();
                    mImageReader = null;
                }
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
            }
            finally
            {
                mCameraOpenCloseLock.Release();
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                CloseCamera();
                StopBackgroundThread();

                if (Element != null)
                {
                }
            }

            base.Dispose(disposing);
        }

        // Starts a background thread and its {@link Handler}.
        private void StartBackgroundThread()
        {
            mBackgroundThread = new HandlerThread("CameraBackground");
            mBackgroundThread.Start();
            mBackgroundHandler = new Handler(mBackgroundThread.Looper);
        }

        // Stops the background thread and its {@link Handler}.
        private void StopBackgroundThread()
        {
            if (mBackgroundThread == null)
            {
                return;
            }

            mBackgroundThread.QuitSafely();
            try
            {
                mBackgroundThread.Join();
                mBackgroundThread = null;
                mBackgroundHandler = null;
            }
            catch (InterruptedException e)
            {
                e.PrintStackTrace();
            }
        }

        // Creates a new {@link CameraCaptureSession} for camera preview.
        public void CreateCameraPreviewSession()
        {
            try
            {
                SurfaceTexture texture = mTextureView.SurfaceTexture;
                if (texture == null)
                {
                    throw new IllegalStateException("texture is null");
                }

                // We configure the size of default buffer to be the size of camera preview we want.
                texture.SetDefaultBufferSize(mPreviewSize.Width, mPreviewSize.Height);

                // This is the output Surface we need to start preview.
                Surface surface = new Surface(texture);

                // We set up a CaptureRequest.Builder with the output Surface.
                mPreviewRequestBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.Preview);
                mPreviewRequestBuilder.AddTarget(surface);
                mPreviewRequestBuilder.AddTarget(mImageReader.Surface);

                // Here, we create a CameraCaptureSession for camera preview.
                var surfaces = new List<Surface>
                {
                    surface,
                    mImageReader.Surface,
                };
                mCameraDevice.CreateCaptureSession(surfaces, new CameraCaptureSessionCallback(this), null);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        // Initiate a still image capture.
        public Task<string> TakePictureAsync()
        {
            if (captureTcs != null)
            {
                captureTcs.TrySetCanceled();
            }

            captureTcs = new TaskCompletionSource<string>();

            mOnImageAvailableListener.AllowCaptureStillImageShot();

            return captureTcs.Task;
        }

        private TaskCompletionSource<string> captureTcs;
        private CameraPreview element;

        public int GetOrientation()
        {
            int rotation = (int)Activity.WindowManager.DefaultDisplay.Rotation;

            // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
            // We have to take that into account and rotate JPEG properly.
            // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.
            // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
            return (Orientations.Get(rotation) + mSensorOrientation + 270) % 360;
        }
    }
}